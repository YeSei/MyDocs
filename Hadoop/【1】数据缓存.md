# 【1】数据缓存

## 1.缓存穿透
> **缓存穿透**：是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

> **解决方案**：最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。


## 2.缓存雪崩
> **缓存雪崩**：是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。

> **解决方案**：用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。


## 3.缓存击穿
> **缓存击穿**：缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
>     对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“**热点**”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，**这个和缓存雪崩的区别**在于这里针对某一key缓存，前者则是很多key。

> **解决方案**：
> - 使用**互斥锁**（mutex key):发现key失效，先由互斥的缓存工具设置mutex key，并进行load存储系统的key。
> - 在value内部设置一个**超时值**，这个超时值比实际超时值要小，每当key到期时，马上延长这个超时值的时间，并从数据库load key。
> - 实现“**永不过期**”，比如redis，讲过期时间加入key对应的value，快要到期时开启异步线程构建缓存刷新。
> - **资源保护**：采用netflix的hystrix，可以做资源的隔离保护主线程池。但是部分访问存在降级问题。